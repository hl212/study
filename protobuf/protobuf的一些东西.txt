#coding=utf-8
https://developers.google.com/protocol-buffers/docs/overview

关于protobuf的一些东西
    关于最小化存储空间，一个message里面最好域在15个内（标签是1--15 ）——只需一个字节空间即可，超过16个可以考虑分message存储
	整数数据尽量使用小数据，占空间少


结构定义
message Item
{
  optional  int32  id = 1;
  optional  int32  num = 2;
}

message Bag
{
    repeated Item  its = 1;
}

1、protobuf 编码——基于Base 128 Varints （7位有效位数）
   对于8字节 第一位0 表示后面没有数字了 1表示后面还有数字

   数值1    ==》 00000001
                  0000001  --》1
  
   数值300  ==》 10101100 00000010 
                  0101100  0000010  --》 000101100 0000010  --》  300

   1个字节编码数值  0 -- 127      2^7
   2个字节编码数值  128 -- 16383  2^14
   3个字节编码数值		  2^21
   也就是说 小于128的整数只需要1个字节存储，小于16383 需要2个字节。。。

2、protobuf 存储结构
   key-value , key-value ...

   key =  (field_number << 3) | wire_type
   wire_type 域的类型 3位表示（见下面表） 
   field_number  定义类型的域数值   
   
   由128编码可知道
   1个字节编码field_number范围：0 -- 15      2^4  类型占3位，剩下4位
   2个字节编码field_number范围：16 -- 2047   2^11

protobuf 类型表
Type	Meaning	           Used For
0	Varint	           int32, int64, uint32, uint64, sint32, sint64, bool, enum
1	64-bit	           fixed64, sfixed64, double
2	Length-delimited   string, bytes, embedded messages, packed repeated fields
3	Start group	   groups (deprecated)
4	End group	   groups (deprecated)
5	32-bit	           fixed32, sfixed32, float


3、string、message（类型2） 需要一个长度字段表示有后面有多少数据
   对于0--127 长度需要 1个字节
   对于0--16383  长度需要 2个字节


4、一些类型的兼容
https://developers.google.com/protocol-buffers/docs/proto#updating

  int32, uint32, int64, uint64, and bool are all compatible
  sint32 and sint64 are compatible 
  string and bytes are compatible as long as the bytes are valid UTF-8.
  fixed32 is compatible with sfixed32, and fixed64 with sfixed64.
  **optional is compatible with repeated. 

  也就是兼容的message字段类型可以互换，不会破坏message数据的结构


5、protobuf数据是向前和向后都兼容的——这个对分布式服务器升级是一个很好的优势，可以平滑不用停机升级服务。

	protobuf data  
		old --- new
			+entry

		old ---> new    新的字段entry 没有

		new -->  old 忽略新的域， 未能识别的域（unknown fields）没有被抛弃， 新的域还是可以利用


	


 